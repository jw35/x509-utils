#!/usr/bin/env python
from __future__ import print_function

'''
A wrapper around 'openssl req' to simplify creating keys and
certificate signing requests (CSR) from the command
line. Significantly it makes it possible to include Subject
Alternative Names in such requests -- something that normally requires
the creation of an OpenSSL configuration file.

  Usage: make-csr [options] [hostnames]

Hostnames to include in the CSR can be supplied on the command line;
if not they are read from standard input. The first name supplied
forms the CN component of the subject name in the request; subsequent
names appear in 'Subject Alternative Name' (SAN) extensions.

The command creates a new 2048-bit RSA key and a sha256-signed CSR in
files with named after the first host name in the request. The CSR is
also output to standard output. The command won't overwrite an
existing key unless --force is supplied. The key will be encrypted
unless --nocrypt is specified. If the key isn't encrypted it will only
be readable by the user running the command (at least on Unix).

The subject name in the request should be acceptable to CAs that
provide most identification information themselves (such as QuoVadis
under the Jisc agreement). By default the name includes only "C=GB"
and a single CN field. The --ou option allows an Organization Unit
component to be included, --c option allows the default country to be
replaced.

Options summary:
  -h, --help  show this help message and exit
  --ou=OU     set the Organization Unit in the request to OU (omit by default)
  --c=C       set the Country code in the request to C (default GB)
  --force     force overwrite of existing key file
  --nocrypt   disable key encryption
'''

import tempfile
import subprocess
import optparse
import sys
import os.path

usage = "usage: %prog [options] [hostnames]"
parser = optparse.OptionParser(usage=usage)
parser.add_option("--ou", dest="ou", action="store",
                  help="set the Organization Unit in the request to OU (omit by default)")
parser.add_option("--c", dest="c", action="store", default='GB',
                  help="set the Country code in the request to C (default GB)")
parser.add_option("--force", dest="force", action="store_true",
                  help="force overwrite of existing key file")
parser.add_option("--nocrypt", dest="nocrypt", action="store_true",
                  help="disable key encryption")          
(options, args) = parser.parse_args()

hostnames = []
if args:
    hostnames = args
else:
    for line in sys.stdin.readlines():
        hostnames.append(line.strip())
	
if len(hostnames) < 1:
    print("No hostnames supplied - need at least one", file=sys.stderr)
    sys.exit(1)

basename = hostnames[0].replace('.','_')
basename = basename.replace('*','STAR')
key = basename + '.key'
newkey = key + '.new'
csr = basename + '.csr'
newcsr = csr + '.new'

if os.path.exists(key) and not options.force:
    print("Key file '%s' exists - won't overwrite" % (key), file=sys.stderr)
    print("Delete the file or use --force to regenerate", file=sys.stderr)
    sys.exit(2)

try:

    # Need delete=False so file can closed (for Windows) and not deleted
    config = tempfile.NamedTemporaryFile(delete=False, mode='w+t')
    config.write("[ req ]\n")
    config.write("default_bits = 2048\n")
    config.write("default_md = sha256\n")
    config.write("distinguished_name = dn\n")
    config.write("string_mask = nombstr\n")
    config.write("prompt = no\n")
    if options.nocrypt:
        config.write("encrypt_key = no\n")
    if len(hostnames) > 1:
        config.write("req_extensions = ext\n")
        config.write("[ ext ]\n")
        config.write("subjectAltName=@alt_section\n")
    config.write("[ dn ]\n")
    config.write("countryName = %s\n" % (options.c))
    if options.ou:
        config.write("organizationalUnitName=%s\n" % (options.ou))
    config.write("commonName = %s\n" % (hostnames[0]))
    if len(hostnames) > 1:
        config.write("[ alt_section ]\n")
        for index, value in enumerate(hostnames[1:]):
            config.write("DNS.%d=%s\n" % (index,value))

    # Close the file so it can be opened by openssl under Windows
    config.close()

    # Delete pre-existing temp files so we can detect creation
    if os.path.exists(newkey): os.remove(newkey)
    if os.path.exists(newcsr): os.remove(newcsr)

    # Restrict visability of created files (esp. the key)
    if options.nocrypt:       
        os.umask(0o066)

    req = ["openssl", "req", 
           "-config", config.name,
           "-new", 
           "-out", newcsr, 
           "-keyout", newkey]

    try:
        subprocess.check_call(req)
    except OSError as e:
        print("'"+ e.strerror + "' " + 
              "when executing the 'openssl' command", file=sys.stderr)
        print("(is OpenSSL installed?)", file=sys.stderr)
        sys.exit(4)
    except subprocess.CalledProcessError as e:
        sys.exit(e.returncode)

    # Only if new files created (openssl error reporting is unreliable)
    if os.path.exists(newcsr) and os.path.exists(newkey):
        # os.rename fails on Windows if dest exists
        if os.name == 'nt':
            if os.path.exists(key): os.remove(key)
            if os.path.exists(csr): os.remove(csr)
        os.rename(newkey,key)
        os.rename(newcsr,csr)
        # Relax access restrictions on created CSR
        if options.nocrypt:
            os.chmod(csr,0o644)
        with open(csr) as csr_file:
            print((csr_file.read()))
    else:
        print("Key/CSR generation failed", file=sys.stderr)
        sys.exit(5)
        
finally:
    os.remove(config.name)
